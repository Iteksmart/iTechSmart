"""
AI-powered diagnosis engine with offline capability
"""

import asyncio
import logging
from typing import Dict, List, Any, Optional
import json
import re
from datetime import datetime

from ..core.models import Alert, Diagnosis, SeverityLevel, Platform


class AIDiagnosisEngine:
    """AI engine for diagnosing infrastructure issues"""
    
    def __init__(self, api_key: Optional[str] = None, offline_mode: bool = True):
        self.offline_mode = offline_mode
        self.api_key = api_key
        self.logger = logging.getLogger(__name__)
        self.knowledge_base = self.load_knowledge_base()
        
        if not offline_mode and api_key:
            try:
                import openai
                openai.api_key = api_key
                self.openai = openai
                self.logger.info("AI engine initialized in online mode")
            except ImportError:
                self.logger.warning("OpenAI not available, falling back to offline mode")
                self.offline_mode = True
        else:
            self.logger.info("AI engine initialized in offline mode")
    
    def load_knowledge_base(self) -> Dict[str, Any]:
        """Load knowledge base for offline diagnosis"""
        return {
            'cpu_issues': {
                'patterns': [
                    {'pattern': r'backup.*\.sh', 'action': 'kill_process', 'risk': 'low'},
                    {'pattern': r'python.*runaway', 'action': 'kill_process', 'risk': 'low'},
                    {'pattern': r'java.*heap', 'action': 'restart_service', 'risk': 'medium'},
                ],
                'thresholds': {
                    'high': 80,
                    'critical': 95
                }
            },
            'memory_issues': {
                'patterns': [
                    {'pattern': r'java', 'action': 'increase_heap', 'risk': 'medium'},
                    {'pattern': r'cache', 'action': 'clear_cache', 'risk': 'low'},
                    {'pattern': r'leak', 'action': 'restart_service', 'risk': 'high'},
                ],
                'thresholds': {
                    'high': 85,
                    'critical': 95
                }
            },
            'disk_issues': {
                'patterns': [
                    {'pattern': r'log', 'action': 'rotate_logs', 'risk': 'low'},
                    {'pattern': r'tmp', 'action': 'clean_tmp', 'risk': 'low'},
                    {'pattern': r'cache', 'action': 'clear_cache', 'risk': 'low'},
                ],
                'thresholds': {
                    'high': 80,
                    'critical': 90
                }
            },
            'security_issues': {
                'brute_force': {
                    'action': 'block_ip',
                    'risk': 'low',
                    'threshold': 5
                },
                'rootkit': {
                    'action': 'quarantine_host',
                    'risk': 'critical',
                    'threshold': 1
                },
                'malware': {
                    'action': 'isolate_and_scan',
                    'risk': 'high',
                    'threshold': 1
                }
            }
        }
    
    async def diagnose_issue(self, alert: Alert, context: Optional[Dict[str, Any]] = None) -> Diagnosis:
        """Diagnose an infrastructure issue"""
        self.logger.info(f"Diagnosing alert: {alert.id} - {alert.message}")
        
        # Gather context if not provided
        if context is None:
            context = await self.gather_context(alert)
        
        # Use AI or offline diagnosis
        if self.offline_mode:
