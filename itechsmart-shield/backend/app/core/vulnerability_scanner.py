"""
Vulnerability Scanner for iTechSmart Shield
Scans systems and applications for security vulnerabilities
"""
import asyncio
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime
import re
import socket

from sqlalchemy.orm import Session
from app.models.security import Vulnerability, ThreatSeverity

logger = logging.getLogger(__name__)


class VulnerabilityScanner:
    """
    Comprehensive vulnerability scanner
    
    Capabilities:
    1. Network vulnerability scanning
    2. Web application scanning
    3. Configuration scanning
    4. Dependency scanning
    5. CVE database integration
    6. CVSS scoring
    """
    
    def __init__(self, db: Session):
        self.db = db
        
        # Configuration
        self.config = {
            "enabled": True,
            "scan_interval": 86400,  # 24 hours
            "deep_scan": False,
            "auto_patch": False,
        }
        
        # Known vulnerabilities database (simplified)
        self.cve_database = {}
        
    async def scan_system(
        self,
        target: str,
        scan_type: str = "comprehensive"
    ) -> Dict[str, Any]:
        """Scan a system for vulnerabilities"""
        
        logger.info(f"ðŸ” Starting vulnerability scan: {target}")
        
        vulnerabilities = []
        
        if scan_type in ["comprehensive", "network"]:
            network_vulns = await self._scan_network(target)
            vulnerabilities.extend(network_vulns)
        
        if scan_type in ["comprehensive", "web"]:
            web_vulns = await self._scan_web_application(target)
            vulnerabilities.extend(web_vulns)
        
        if scan_type in ["comprehensive", "config"]:
            config_vulns = await self._scan_configuration(target)
            vulnerabilities.extend(config_vulns)
        
        # Store vulnerabilities
        for vuln in vulnerabilities:
            await self._store_vulnerability(vuln, target)
        
        return {
            "target": target,
            "scan_type": scan_type,
            "vulnerabilities_found": len(vulnerabilities),
            "critical": len([v for v in vulnerabilities if v["severity"] == ThreatSeverity.CRITICAL]),
            "high": len([v for v in vulnerabilities if v["severity"] == ThreatSeverity.HIGH]),
            "medium": len([v for v in vulnerabilities if v["severity"] == ThreatSeverity.MEDIUM]),
            "low": len([v for v in vulnerabilities if v["severity"] == ThreatSeverity.LOW]),
            "vulnerabilities": vulnerabilities
        }
    
    async def scan_dependencies(
        self,
        dependencies: List[Dict[str, str]]
    ) -> List[Dict[str, Any]]:
        """Scan dependencies for known vulnerabilities"""
        
        vulnerabilities = []
        
        for dep in dependencies:
            name = dep.get("name")
            version = dep.get("version")
            
            # Check against CVE database
            vulns = await self._check_cve_database(name, version)
            vulnerabilities.extend(vulns)
        
        return vulnerabilities
    
    async def _scan_network(self, target: str) -> List[Dict]:
        """Scan network for vulnerabilities"""
        
        vulnerabilities = []
        
        # Port scan
        open_ports = await self._scan_ports(target)
        
        for port in open_ports:
            # Check for known vulnerable services
            if port in [21, 23, 25]:  # FTP, Telnet, SMTP
                vulnerabilities.append({
                    "type": "insecure_service",
                    "severity": ThreatSeverity.HIGH,
                    "description": f"Insecure service running on port {port}",
                    "port": port,
                    "remediation": f"Disable or secure service on port {port}"
                })
        
        # Check for weak SSL/TLS
        if 443 in open_ports:
            ssl_vulns = await self._check_ssl_vulnerabilities(target)
            vulnerabilities.extend(ssl_vulns)
        
        return vulnerabilities
    
    async def _scan_web_application(self, target: str) -> List[Dict]:
        """Scan web application for vulnerabilities"""
        
        vulnerabilities = []
        
        # Check for common web vulnerabilities
        # OWASP Top 10
        
        # 1. SQL Injection
        sql_vuln = await self._test_sql_injection(target)
        if sql_vuln:
            vulnerabilities.append(sql_vuln)
        
        # 2. XSS
        xss_vuln = await self._test_xss(target)
        if xss_vuln:
            vulnerabilities.append(xss_vuln)
        
        # 3. Security misconfiguration
        misconfig_vulns = await self._check_security_misconfigurations(target)
        vulnerabilities.extend(misconfig_vulns)
        
        # 4. Sensitive data exposure
        data_exposure_vulns = await self._check_data_exposure(target)
        vulnerabilities.extend(data_exposure_vulns)
        
        return vulnerabilities
    
    async def _scan_configuration(self, target: str) -> List[Dict]:
        """Scan system configuration for vulnerabilities"""
        
        vulnerabilities = []
        
        # Check for weak passwords
        weak_password_vuln = await self._check_weak_passwords(target)
        if weak_password_vuln:
            vulnerabilities.append(weak_password_vuln)
        
        # Check for missing patches
        patch_vulns = await self._check_missing_patches(target)
        vulnerabilities.extend(patch_vulns)
        
        # Check for insecure configurations
        config_vulns = await self._check_insecure_configurations(target)
        vulnerabilities.extend(config_vulns)
        
        return vulnerabilities
    
    async def _scan_ports(self, target: str) -> List[int]:
        """Scan for open ports"""
        
        open_ports = []
        common_ports = [21, 22, 23, 25, 80, 443, 3306, 5432, 8080, 8443]
        
        for port in common_ports:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((target, port))
                if result == 0:
                    open_ports.append(port)
                sock.close()
            except:
                pass
        
        return open_ports
    
    async def _check_ssl_vulnerabilities(self, target: str) -> List[Dict]:
        """Check for SSL/TLS vulnerabilities"""
        
        vulnerabilities = []
        
        # Simplified - in production, use proper SSL scanning
        # Check for weak ciphers, expired certificates, etc.
        
        return vulnerabilities
    
    async def _test_sql_injection(self, target: str) -> Optional[Dict]:
        """Test for SQL injection vulnerabilities"""
        
        # Simplified - in production, use proper testing
        # This would test various SQL injection payloads
        
        return None
    
    async def _test_xss(self, target: str) -> Optional[Dict]:
        """Test for XSS vulnerabilities"""
        
        # Simplified - in production, use proper testing
        
        return None
    
    async def _check_security_misconfigurations(self, target: str) -> List[Dict]:
        """Check for security misconfigurations"""
        
        vulnerabilities = []
        
        # Check for:
        # - Default credentials
        # - Directory listing enabled
        # - Unnecessary services running
        # - Missing security headers
        
        return vulnerabilities
    
    async def _check_data_exposure(self, target: str) -> List[Dict]:
        """Check for sensitive data exposure"""
        
        vulnerabilities = []
        
        # Check for:
        # - Exposed API keys
        # - Exposed credentials
        # - Exposed PII
        
        return vulnerabilities
    
    async def _check_weak_passwords(self, target: str) -> Optional[Dict]:
        """Check for weak passwords"""
        
        # Simplified - in production, use proper password auditing
        
        return None
    
    async def _check_missing_patches(self, target: str) -> List[Dict]:
        """Check for missing security patches"""
        
        vulnerabilities = []
        
        # Check system for missing patches
        # Compare installed versions with latest secure versions
        
        return vulnerabilities
    
    async def _check_insecure_configurations(self, target: str) -> List[Dict]:
        """Check for insecure configurations"""
        
        vulnerabilities = []
        
        # Check for:
        # - Weak encryption
        # - Insecure protocols
        # - Excessive permissions
        
        return vulnerabilities
    
    async def _check_cve_database(
        self,
        package_name: str,
        version: str
    ) -> List[Dict]:
        """Check package against CVE database"""
        
        vulnerabilities = []
        
        # In production, query actual CVE database
        # For now, return empty list
        
        return vulnerabilities
    
    async def _store_vulnerability(
        self,
        vuln_data: Dict,
        target: str
    ):
        """Store discovered vulnerability"""
        
        vulnerability = Vulnerability(
            discovered_at=datetime.utcnow(),
            vulnerability_type=vuln_data.get("type"),
            severity=vuln_data.get("severity"),
            affected_asset=target,
            asset_type="system",
            description=vuln_data.get("description"),
            remediation=vuln_data.get("remediation"),
            cvss_score=vuln_data.get("cvss_score"),
            risk_score=self._calculate_risk_score(vuln_data),
            status="open"
        )
        
        self.db.add(vulnerability)
        self.db.commit()
        
        logger.warning(
            f"ðŸ” Vulnerability found: {vuln_data.get('type')} "
            f"on {target} (severity: {vuln_data.get('severity')})"
        )
    
    def _calculate_risk_score(self, vuln_data: Dict) -> float:
        """Calculate risk score for vulnerability"""
        
        severity_scores = {
            ThreatSeverity.CRITICAL: 10.0,
            ThreatSeverity.HIGH: 7.5,
            ThreatSeverity.MEDIUM: 5.0,
            ThreatSeverity.LOW: 2.5
        }
        
        base_score = severity_scores.get(vuln_data.get("severity"), 5.0)
        
        # Adjust based on exploitability
        if vuln_data.get("exploit_available"):
            base_score *= 1.5
        
        return min(base_score, 10.0)
    
    async def get_vulnerability_report(
        self,
        asset: Optional[str] = None
    ) -> Dict[str, Any]:
        """Generate vulnerability report"""
        
        query = self.db.query(Vulnerability)
        
        if asset:
            query = query.filter(Vulnerability.affected_asset == asset)
        
        vulnerabilities = query.filter(Vulnerability.status == "open").all()
        
        return {
            "total_vulnerabilities": len(vulnerabilities),
            "critical": len([v for v in vulnerabilities if v.severity == ThreatSeverity.CRITICAL]),
            "high": len([v for v in vulnerabilities if v.severity == ThreatSeverity.HIGH]),
            "medium": len([v for v in vulnerabilities if v.severity == ThreatSeverity.MEDIUM]),
            "low": len([v for v in vulnerabilities if v.severity == ThreatSeverity.LOW]),
            "vulnerabilities": [
                {
                    "id": v.id,
                    "type": v.vulnerability_type,
                    "severity": v.severity.value,
                    "asset": v.affected_asset,
                    "description": v.description,
                    "cvss_score": v.cvss_score,
                    "discovered_at": v.discovered_at.isoformat()
                }
                for v in vulnerabilities
            ]
        }