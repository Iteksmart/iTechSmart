from fastapi import FastAPI, Depends, HTTPException, status, UploadFile, File
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from typing import List, Optional
from datetime import datetime, timedelta
import secrets
from passlib.context import CryptContext
from jose import JWTError, jwt
import json

import models
import schemas
from database import engine, get_db, get_redis

# Create database tables
models.Base.metadata.create_all(bind=engine)

# Initialize FastAPI app
app = FastAPI(
    title="iTechSmart Copilot API",
    description="AI Assistant Platform - Multi-model AI integration with conversation management",
    version="1.0.0"
)

# CORS Configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Security Configuration
SECRET_KEY = "your-secret-key-change-in-production"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# Helper Functions
def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

async def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: int = payload.get("sub")
        if user_id is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    
    user = db.query(models.User).filter(models.User.id == user_id).first()
    if user is None:
        raise credentials_exception
    return user

# Simulated AI response function (replace with actual AI integration)
def generate_ai_response(message: str, model_id: int, system_prompt: Optional[str] = None, 
                        temperature: float = 0.7, max_tokens: int = 1000) -> dict:
    """
    Simulated AI response generation.
    In production, this would integrate with OpenAI, Anthropic, Google, etc.
    """
    # Simulate token usage and cost
    tokens = len(message.split()) * 2  # Simplified token calculation
    cost = (tokens / 1000) * 0.002  # Simplified cost calculation
    
    # Generate response based on message
    response_text = f"This is a simulated AI response to: '{message}'. In production, this would be generated by the selected AI model with proper integration."
    
    return {
        "content": response_text,
        "tokens": tokens,
        "cost": cost
    }

# Root Endpoint
@app.get("/")
async def root():
    return {
        "message": "iTechSmart Copilot API",
        "version": "1.0.0",
        "status": "operational"
    }

# Health Check
@app.get("/health")
async def health_check():
    return {"status": "healthy", "timestamp": datetime.utcnow()}

# Authentication Endpoints
@app.post("/auth/register", response_model=schemas.UserResponse)
async def register(user: schemas.UserCreate, db: Session = Depends(get_db)):
    # Check if user exists
    db_user = db.query(models.User).filter(models.User.email == user.email).first()
    if db_user:
        raise HTTPException(status_code=400, detail="Email already registered")
    
    db_user = db.query(models.User).filter(models.User.username == user.username).first()
    if db_user:
        raise HTTPException(status_code=400, detail="Username already taken")
    
    # Create new user
    hashed_password = get_password_hash(user.password)
    db_user = models.User(
        email=user.email,
        username=user.username,
        full_name=user.full_name,
        hashed_password=hashed_password
    )
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

@app.post("/auth/login", response_model=schemas.Token)
async def login(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):
    user = db.query(models.User).filter(models.User.username == form_data.username).first()
    if not user or not verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": str(user.id)}, expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}

@app.get("/auth/me", response_model=schemas.UserResponse)
async def get_current_user_info(current_user: models.User = Depends(get_current_user)):
    return current_user

# AI Model Endpoints
@app.post("/models", response_model=schemas.AIModelResponse)
async def create_model(
    model: schemas.AIModelCreate,
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    if not current_user.is_admin:
        raise HTTPException(status_code=403, detail="Admin access required")
    
    db_model = models.AIModel(**model.dict())
    db.add(db_model)
    db.commit()
    db.refresh(db_model)
    return db_model

@app.get("/models", response_model=List[schemas.AIModelResponse])
async def get_models(
    skip: int = 0,
    limit: int = 100,
    provider: Optional[str] = None,
    db: Session = Depends(get_db)
):
    query = db.query(models.AIModel).filter(models.AIModel.is_active == True)
    if provider:
        query = query.filter(models.AIModel.provider == provider)
    models_list = query.offset(skip).limit(limit).all()
    return models_list

@app.get("/models/{model_id}", response_model=schemas.AIModelResponse)
async def get_model(model_id: int, db: Session = Depends(get_db)):
    model = db.query(models.AIModel).filter(models.AIModel.id == model_id).first()
    if not model:
        raise HTTPException(status_code=404, detail="Model not found")
    return model

@app.put("/models/{model_id}", response_model=schemas.AIModelResponse)
async def update_model(
    model_id: int,
    model_update: schemas.AIModelUpdate,
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    if not current_user.is_admin:
        raise HTTPException(status_code=403, detail="Admin access required")
    
    db_model = db.query(models.AIModel).filter(models.AIModel.id == model_id).first()
    if not db_model:
        raise HTTPException(status_code=404, detail="Model not found")
    
    for key, value in model_update.dict(exclude_unset=True).items():
        setattr(db_model, key, value)
    
    db.commit()
    db.refresh(db_model)
    return db_model

# Conversation Endpoints
@app.post("/conversations", response_model=schemas.ConversationResponse)
async def create_conversation(
    conversation: schemas.ConversationCreate,
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    db_conversation = models.Conversation(
        user_id=current_user.id,
        **conversation.dict()
    )
    db.add(db_conversation)
    db.commit()
    db.refresh(db_conversation)
    return db_conversation

@app.get("/conversations", response_model=List[schemas.ConversationResponse])
async def get_conversations(
    skip: int = 0,
    limit: int = 100,
    status: Optional[str] = None,
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    query = db.query(models.Conversation).filter(models.Conversation.user_id == current_user.id)
    if status:
        query = query.filter(models.Conversation.status == status)
    conversations = query.order_by(models.Conversation.updated_at.desc()).offset(skip).limit(limit).all()
    return conversations

@app.get("/conversations/{conversation_id}", response_model=schemas.ConversationResponse)
async def get_conversation(
    conversation_id: int,
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    conversation = db.query(models.Conversation).filter(
        models.Conversation.id == conversation_id,
        models.Conversation.user_id == current_user.id
    ).first()
    if not conversation:
        raise HTTPException(status_code=404, detail="Conversation not found")
    return conversation

@app.put("/conversations/{conversation_id}", response_model=schemas.ConversationResponse)
async def update_conversation(
    conversation_id: int,
    conversation_update: schemas.ConversationUpdate,
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    conversation = db.query(models.Conversation).filter(
        models.Conversation.id == conversation_id,
        models.Conversation.user_id == current_user.id
    ).first()
    if not conversation:
        raise HTTPException(status_code=404, detail="Conversation not found")
    
    for key, value in conversation_update.dict(exclude_unset=True).items():
        setattr(conversation, key, value)
    
    conversation.updated_at = datetime.utcnow()
    db.commit()
    db.refresh(conversation)
    return conversation

@app.delete("/conversations/{conversation_id}")
async def delete_conversation(
    conversation_id: int,
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    conversation = db.query(models.Conversation).filter(
        models.Conversation.id == conversation_id,
        models.Conversation.user_id == current_user.id
    ).first()
    if not conversation:
        raise HTTPException(status_code=404, detail="Conversation not found")
    
    db.delete(conversation)
    db.commit()
    return {"message": "Conversation deleted successfully"}

# Message Endpoints
@app.get("/conversations/{conversation_id}/messages", response_model=List[schemas.MessageResponse])
async def get_messages(
    conversation_id: int,
    skip: int = 0,
    limit: int = 100,
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    # Verify conversation ownership
    conversation = db.query(models.Conversation).filter(
        models.Conversation.id == conversation_id,
        models.Conversation.user_id == current_user.id
    ).first()
    if not conversation:
        raise HTTPException(status_code=404, detail="Conversation not found")
    
    messages = db.query(models.Message).filter(
        models.Message.conversation_id == conversation_id
    ).order_by(models.Message.created_at).offset(skip).limit(limit).all()
    return messages

# Chat Endpoint
@app.post("/chat", response_model=schemas.ChatResponse)
async def chat(
    chat_request: schemas.ChatRequest,
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    # Get or create conversation
    if chat_request.conversation_id:
        conversation = db.query(models.Conversation).filter(
            models.Conversation.id == chat_request.conversation_id,
            models.Conversation.user_id == current_user.id
        ).first()
        if not conversation:
            raise HTTPException(status_code=404, detail="Conversation not found")
    else:
        # Create new conversation
        model_id = chat_request.model_id or 1  # Default model
        conversation = models.Conversation(
            user_id=current_user.id,
            model_id=model_id,
            title=chat_request.message[:50] + "..." if len(chat_request.message) > 50 else chat_request.message,
            system_prompt=chat_request.system_prompt
        )
        db.add(conversation)
        db.commit()
        db.refresh(conversation)
    
    # Create user message
    user_message = models.Message(
        conversation_id=conversation.id,
        role=models.MessageRole.USER,
        content=chat_request.message,
        tokens=len(chat_request.message.split()),
        cost=0.0
    )
    db.add(user_message)
    db.commit()
    db.refresh(user_message)
    
    # Generate AI response
    ai_response_data = generate_ai_response(
        chat_request.message,
        conversation.model_id,
        chat_request.system_prompt or conversation.system_prompt,
        chat_request.temperature or 0.7,
        chat_request.max_tokens or 1000
    )
    
    # Create assistant message
    assistant_message = models.Message(
        conversation_id=conversation.id,
        role=models.MessageRole.ASSISTANT,
        content=ai_response_data["content"],
        tokens=ai_response_data["tokens"],
        cost=ai_response_data["cost"]
    )
    db.add(assistant_message)
    
    # Update conversation stats
    conversation.total_tokens += user_message.tokens + assistant_message.tokens
    conversation.total_cost += assistant_message.cost
    conversation.updated_at = datetime.utcnow()
    
    db.commit()
    db.refresh(assistant_message)
    
    return schemas.ChatResponse(
        conversation_id=conversation.id,
        message=user_message,
        response=assistant_message,
        total_tokens=user_message.tokens + assistant_message.tokens,
        cost=assistant_message.cost
    )

# Prompt Template Endpoints
@app.post("/prompts", response_model=schemas.PromptTemplateResponse)
async def create_prompt(
    prompt: schemas.PromptTemplateCreate,
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    db_prompt = models.PromptTemplate(
        user_id=current_user.id,
        **prompt.dict()
    )
    db.add(db_prompt)
    db.commit()
    db.refresh(db_prompt)
    return db_prompt

@app.get("/prompts", response_model=List[schemas.PromptTemplateResponse])
async def get_prompts(
    skip: int = 0,
    limit: int = 100,
    category: Optional[str] = None,
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    query = db.query(models.PromptTemplate).filter(
        (models.PromptTemplate.user_id == current_user.id) | 
        (models.PromptTemplate.is_public == True)
    )
    if category:
        query = query.filter(models.PromptTemplate.category == category)
    prompts = query.offset(skip).limit(limit).all()
    return prompts

@app.get("/prompts/{prompt_id}", response_model=schemas.PromptTemplateResponse)
async def get_prompt(
    prompt_id: int,
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    prompt = db.query(models.PromptTemplate).filter(
        models.PromptTemplate.id == prompt_id,
        (models.PromptTemplate.user_id == current_user.id) | 
        (models.PromptTemplate.is_public == True)
    ).first()
    if not prompt:
        raise HTTPException(status_code=404, detail="Prompt not found")
    return prompt

@app.put("/prompts/{prompt_id}", response_model=schemas.PromptTemplateResponse)
async def update_prompt(
    prompt_id: int,
    prompt_update: schemas.PromptTemplateUpdate,
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    prompt = db.query(models.PromptTemplate).filter(
        models.PromptTemplate.id == prompt_id,
        models.PromptTemplate.user_id == current_user.id
    ).first()
    if not prompt:
        raise HTTPException(status_code=404, detail="Prompt not found")
    
    for key, value in prompt_update.dict(exclude_unset=True).items():
        setattr(prompt, key, value)
    
    db.commit()
    db.refresh(prompt)
    return prompt

@app.delete("/prompts/{prompt_id}")
async def delete_prompt(
    prompt_id: int,
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    prompt = db.query(models.PromptTemplate).filter(
        models.PromptTemplate.id == prompt_id,
        models.PromptTemplate.user_id == current_user.id
    ).first()
    if not prompt:
        raise HTTPException(status_code=404, detail="Prompt not found")
    
    db.delete(prompt)
    db.commit()
    return {"message": "Prompt deleted successfully"}

# Document Endpoints
@app.post("/documents", response_model=schemas.DocumentResponse)
async def create_document(
    document: schemas.DocumentCreate,
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    db_document = models.Document(
        user_id=current_user.id,
        file_size=len(document.content),
        **document.dict()
    )
    db.add(db_document)
    db.commit()
    db.refresh(db_document)
    return db_document

@app.get("/documents", response_model=List[schemas.DocumentResponse])
async def get_documents(
    skip: int = 0,
    limit: int = 100,
    document_type: Optional[str] = None,
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    query = db.query(models.Document).filter(models.Document.user_id == current_user.id)
    if document_type:
        query = query.filter(models.Document.document_type == document_type)
    documents = query.offset(skip).limit(limit).all()
    return documents

@app.delete("/documents/{document_id}")
async def delete_document(
    document_id: int,
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    document = db.query(models.Document).filter(
        models.Document.id == document_id,
        models.Document.user_id == current_user.id
    ).first()
    if not document:
        raise HTTPException(status_code=404, detail="Document not found")
    
    db.delete(document)
    db.commit()
    return {"message": "Document deleted successfully"}

# Code Snippet Endpoints
@app.post("/snippets", response_model=schemas.CodeSnippetResponse)
async def create_snippet(
    snippet: schemas.CodeSnippetCreate,
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    db_snippet = models.CodeSnippet(
        user_id=current_user.id,
        **snippet.dict()
    )
    db.add(db_snippet)
    db.commit()
    db.refresh(db_snippet)
    return db_snippet

@app.get("/snippets", response_model=List[schemas.CodeSnippetResponse])
async def get_snippets(
    skip: int = 0,
    limit: int = 100,
    language: Optional[str] = None,
    is_favorite: Optional[bool] = None,
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    query = db.query(models.CodeSnippet).filter(models.CodeSnippet.user_id == current_user.id)
    if language:
        query = query.filter(models.CodeSnippet.language == language)
    if is_favorite is not None:
        query = query.filter(models.CodeSnippet.is_favorite == is_favorite)
    snippets = query.offset(skip).limit(limit).all()
    return snippets

@app.delete("/snippets/{snippet_id}")
async def delete_snippet(
    snippet_id: int,
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    snippet = db.query(models.CodeSnippet).filter(
        models.CodeSnippet.id == snippet_id,
        models.CodeSnippet.user_id == current_user.id
    ).first()
    if not snippet:
        raise HTTPException(status_code=404, detail="Snippet not found")
    
    db.delete(snippet)
    db.commit()
    return {"message": "Snippet deleted successfully"}

# Knowledge Base Endpoints
@app.post("/knowledge-bases", response_model=schemas.KnowledgeBaseResponse)
async def create_knowledge_base(
    kb: schemas.KnowledgeBaseCreate,
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    collection_name = f"kb_{current_user.id}_{secrets.token_hex(8)}"
    db_kb = models.KnowledgeBase(
        user_id=current_user.id,
        collection_name=collection_name,
        **kb.dict()
    )
    db.add(db_kb)
    db.commit()
    db.refresh(db_kb)
    return db_kb

@app.get("/knowledge-bases", response_model=List[schemas.KnowledgeBaseResponse])
async def get_knowledge_bases(
    skip: int = 0,
    limit: int = 100,
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    kbs = db.query(models.KnowledgeBase).filter(
        models.KnowledgeBase.user_id == current_user.id
    ).offset(skip).limit(limit).all()
    return kbs

# Analytics Endpoints
@app.get("/analytics/dashboard", response_model=schemas.DashboardStats)
async def get_dashboard_stats(
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    total_conversations = db.query(models.Conversation).filter(
        models.Conversation.user_id == current_user.id
    ).count()
    
    total_messages = db.query(models.Message).join(models.Conversation).filter(
        models.Conversation.user_id == current_user.id
    ).count()
    
    total_tokens = db.query(models.Conversation).filter(
        models.Conversation.user_id == current_user.id
    ).with_entities(models.Conversation.total_tokens).all()
    total_tokens = sum([t[0] for t in total_tokens]) if total_tokens else 0
    
    total_cost = db.query(models.Conversation).filter(
        models.Conversation.user_id == current_user.id
    ).with_entities(models.Conversation.total_cost).all()
    total_cost = sum([c[0] for c in total_cost]) if total_cost else 0.0
    
    active_conversations = db.query(models.Conversation).filter(
        models.Conversation.user_id == current_user.id,
        models.Conversation.status == models.ConversationStatus.ACTIVE
    ).count()
    
    favorite_snippets = db.query(models.CodeSnippet).filter(
        models.CodeSnippet.user_id == current_user.id,
        models.CodeSnippet.is_favorite == True
    ).count()
    
    documents_count = db.query(models.Document).filter(
        models.Document.user_id == current_user.id
    ).count()
    
    prompts_count = db.query(models.PromptTemplate).filter(
        models.PromptTemplate.user_id == current_user.id
    ).count()
    
    return schemas.DashboardStats(
        total_conversations=total_conversations,
        total_messages=total_messages,
        total_tokens=total_tokens,
        total_cost=total_cost,
        active_conversations=active_conversations,
        favorite_snippets=favorite_snippets,
        documents_count=documents_count,
        prompts_count=prompts_count
    )

# Feedback Endpoints
@app.post("/feedback", response_model=schemas.FeedbackResponse)
async def create_feedback(
    feedback: schemas.FeedbackCreate,
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    db_feedback = models.Feedback(
        user_id=current_user.id,
        **feedback.dict()
    )
    db.add(db_feedback)
    db.commit()
    db.refresh(db_feedback)
    return db_feedback

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)